---
title: Go 运行时（Go runtime）和Java 虚拟机（JVM）区别
date: 2025-07-16 10:55:11
categories:
    - Go
tags:
    - Go
    - runtime
---
Go 运行时（Go runtime）并不像 JVM 那样是一个完整的虚拟机。 虽然两者都负责程序的执行和内存管理，但它们在实现方式和抽象层次上存在显著差异：

**JVM (Java Virtual Machine):**

*   **虚拟机：** JVM 是一个完整的虚拟机，它运行在操作系统之上，提供了一个抽象的硬件平台。
*   **字节码：** Java 源代码被编译成字节码（.class 文件），字节码在 JVM 上解释执行或者通过即时编译（JIT）编译成本地机器码执行。
*   **垃圾回收：** JVM 负责自动垃圾回收，管理内存的分配和释放。
*   **跨平台：** JVM 的主要目标是提供跨平台能力，相同的字节码可以在不同的操作系统上运行。

**Go 运行时 (Go Runtime):**

*   **运行时库：** Go 运行时更像是一个运行时库，而不是一个独立的虚拟机。 它是 Go 程序的一部分，直接嵌入到可执行文件中。
*   **本地机器码：** Go 源代码直接编译成本地机器码，不需要中间的字节码。
*   **垃圾回收：** Go 运行时也负责垃圾回收，与 JVM 类似，它会自动管理内存。
*   **并发调度：** Go 运行时内置了 Goroutine 调度器，负责 Goroutine 的创建、调度和同步。
*   **不跨平台 (代码层面跨平台):** 虽然 Go 代码可以跨平台编译，但是编译后的可执行文件是针对特定平台的本地机器码，不能像 Java 字节码那样在任何安装了 JVM 的平台上运行。 需要在不同的平台上重新编译。 所以Go是代码层面跨平台， 而不是像Java那样，运行文件跨平台。

**主要区别总结：**

| 特性           | JVM                                   | Go 运行时                                |
| -------------- | ------------------------------------- | --------------------------------------- |
| 类型           | 虚拟机                                | 运行时库                                 |
| 执行方式       | 字节码解释/JIT                        | 本地机器码                               |
| 跨平台         | 字节码跨平台 (运行文件跨平台)         | 代码跨平台 (需要重新编译)                |
| 调度           | 依赖操作系统线程                       | 内置 Goroutine 调度器                    |
| 抽象层次       | 更高，提供抽象的硬件平台                | 更低，更接近操作系统                     |
| 是否独立运行   | 是，可以独立运行 Java 程序              | 否，嵌入到 Go 程序中                    |

**简单来说：**

*   JVM 是一个独立的、完整的虚拟机，用于运行 Java 字节码。
*   Go 运行时是一个嵌入到 Go 程序中的运行时库，负责内存管理、垃圾回收和 Goroutine 调度等任务。 Go 程序直接编译成本地机器码执行，不需要虚拟机。

**为什么 Go 没有采用虚拟机？**

Go 语言的设计目标之一是高性能和低延迟。 直接编译成本地机器码可以避免虚拟机带来的性能开销。 此外，Go 运行时内置的 Goroutine 调度器可以更高效地利用多核 CPU，提高并发性能。

总而言之，虽然 Go 运行时和 JVM 都承担着程序执行和内存管理的任务，但它们在实现方式和设计理念上存在显著差异。 Go 运行时更像是一个轻量级的运行时库，而不是一个独立的虚拟机。